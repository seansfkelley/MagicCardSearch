// This file is automatically generated by Citron version 2.0.
//
// The parser class defined below conforms to the CitronParser protocol
// defined in CitronParser.swift. 
// 
// The authors of Citron disclaim copyright to the source code in this file.

// Parser class

class MagicCardSearchGrammar: CitronParser {

    // Types

    typealias CitronSymbolNumber = UInt8
    typealias CitronStateNumber = UInt8
    typealias CitronRuleNumber = UInt8

    enum CitronTokenCode: CitronSymbolNumber {
      case Set                            =   1
      case ManaValue                      =   2
      case Equal                          =   3
      case NotEqual                       =   4
      case LessThan                       =   5
      case LessThanOrEqual                =   6
      case GreaterThan                    =   7
      case GreaterThanOrEqual             =   8
      case Text                           =   9
    }

    enum CitronNonTerminalCode: CitronSymbolNumber {
      case filter                         =  10
      case set_filter                     =  11
      case manavalue_filter               =  12
      case name_filter                    =  13
      case string_comparison              =  14
      case text                           =  15
      case comparison                     =  16
    }

    enum CitronSymbolCode : RawRepresentable, Equatable {
        case token(CitronTokenCode)
        case nonterminal(CitronNonTerminalCode)
        case endOfInput

        init(_ token: CitronTokenCode) { self = .token(token) }
        init(_ nonterminal: CitronNonTerminalCode) { self = .nonterminal(nonterminal) }
        init(rawValue: CitronSymbolNumber) {
            if (rawValue == 0) {
                self = .endOfInput
            } else if (rawValue < 10) {
                self = .token(CitronTokenCode(rawValue: rawValue)!)
            } else if (rawValue < 17) {
                self = .nonterminal(CitronNonTerminalCode(rawValue: rawValue)!)
            } else {
                fatalError()
            }
        }

        typealias RawValue = CitronSymbolNumber
        var rawValue: CitronSymbolNumber {
            switch (self) {
            case .token(let t): return t.rawValue
            case .nonterminal(let nt): return nt.rawValue
            case .endOfInput: return 0
            }
        }
    }

    typealias CitronToken = Token

    enum CitronSymbol {
        case yyBaseOfStack
        case yy0(CitronToken)
        case yy6(String)
        case yy7(Comparison)
        case yy9(SearchFilter)
        case yy21(StringComparison)

        func typeErasedContent() -> Any {
            switch (self) {
            case .yyBaseOfStack: fatalError()
            case .yy0(let value): return value as Any
            case .yy6(let value): return value as Any
            case .yy7(let value): return value as Any
            case .yy9(let value): return value as Any
            case .yy21(let value): return value as Any
            }
        }
    }

    typealias CitronResult = SearchFilter

    // Counts

    let yyNumberOfSymbols: Int = 17
    let yyNumberOfStates: Int = 8

    // Action tables

    let yyLookaheadAction: [(CitronSymbolNumber, CitronParsingAction)] = [
/*   0 */  ( 3, .SR( 8)), ( 4, .SR( 9)), ( 5, .SR(10)), ( 6, .SR(11)), ( 7, .SR(12)),
/*   5 */  ( 8, .SR(13)), (10, .ACCEPT),   (11, .SH( 7)), (12, .SH( 6)), (13, .SH( 5)),
/*  10 */  (16, .SH( 3)), (15, .RD( 5)), (14, .SH( 4)), ( 1, .SH( 2)), ( 2, .SH( 1)),
/*  15 */  ( 9, .SR(14)), (15, .RD( 4)), ( 3, .SR( 6)), ( 4, .SR( 7)), (15, .RD( 3)),
/*  20 */  ( 0, .RD( 2)), ( 9, .SR(14)), ( 0, .RD( 1)), ( 0, .RD( 0)),
    ]

    let yyShiftUseDefault: Int = 24
    let yyShiftOffsetMin: Int = -3
    let yyShiftOffsetMax: Int = 23
    let yyShiftOffset: [Int] = [
        /*     0 */    12,   -3,   14,    6,    6,   20,   22,   23,
    ]

    let yyReduceUseDefault: Int = -7
    let yyReduceOffsetMin: Int =   -6
    let yyReduceOffsetMax: Int =   4
    let yyReduceOffset: [Int] = [
        /*     0 */    -4,   -6,   -2,    1,    4,
    ]

    let yyDefaultAction: [CitronParsingAction] = [
  /*     0 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*     5 */  .ERROR , .ERROR , .ERROR ,
    ]

    // Fallback

    let yyHasFallback: Bool = false
    let yyFallback: [CitronSymbolNumber] = []

    // Wildcard

    let yyWildcard: CitronSymbolNumber? = nil

    // Rules

    let yyRuleInfo: [(lhs: CitronSymbolNumber, nrhs: UInt)] = [
        (lhs: 10, nrhs: 1),
        (lhs: 10, nrhs: 1),
        (lhs: 10, nrhs: 1),
        (lhs: 11, nrhs: 3),
        (lhs: 12, nrhs: 3),
        (lhs: 13, nrhs: 1),
        (lhs: 14, nrhs: 1),
        (lhs: 14, nrhs: 1),
        (lhs: 16, nrhs: 1),
        (lhs: 16, nrhs: 1),
        (lhs: 16, nrhs: 1),
        (lhs: 16, nrhs: 1),
        (lhs: 16, nrhs: 1),
        (lhs: 16, nrhs: 1),
        (lhs: 15, nrhs: 1),
    ]

    // Stack

    var yyStack: [(stateOrRule: CitronStateOrRule , symbolCode: CitronSymbolNumber, symbol: CitronSymbol)]  = [
        (stateOrRule: .state(0), symbolCode: 0, symbol: .yyBaseOfStack)
    ]
    var maxStackSize: Int? = nil
    var maxAttainedStackSize: Int = 0

    // Tracing

    var isTracingEnabled: Bool = false
    var isTracingPrintsSymbolValues: Bool = false
    var isTracingPrintsTokenValues: Bool = false
    let yySymbolName: [String] = [
    /*  0 */ "$",
    /*  1 */ "Set",
    /*  2 */ "ManaValue",
    /*  3 */ "Equal",
    /*  4 */ "NotEqual",
    /*  5 */ "LessThan",
    /*  6 */ "LessThanOrEqual",
    /*  7 */ "GreaterThan",
    /*  8 */ "GreaterThanOrEqual",
    /*  9 */ "Text",
    /* 10 */ "filter",
    /* 11 */ "set_filter",
    /* 12 */ "manavalue_filter",
    /* 13 */ "name_filter",
    /* 14 */ "string_comparison",
    /* 15 */ "text",
    /* 16 */ "comparison",
    ]
    let yyRuleText: [String] = [
        /*   0 */ "filter ::= set_filter(f)",
        /*   1 */ "filter ::= manavalue_filter(f)",
        /*   2 */ "filter ::= name_filter(f)",
        /*   3 */ "set_filter ::= Set string_comparison(c) text(s)",
        /*   4 */ "manavalue_filter ::= ManaValue comparison(c) text(s)",
        /*   5 */ "name_filter ::= text(n)",
        /*   6 */ "string_comparison ::= Equal",
        /*   7 */ "string_comparison ::= NotEqual",
        /*   8 */ "comparison ::= Equal",
        /*   9 */ "comparison ::= NotEqual",
        /*  10 */ "comparison ::= LessThan",
        /*  11 */ "comparison ::= LessThanOrEqual",
        /*  12 */ "comparison ::= GreaterThan",
        /*  13 */ "comparison ::= GreaterThanOrEqual",
        /*  14 */ "text ::= Text(x)",
    ]

    // Function definitions

    func yyTokenToSymbol(_ token: CitronToken) -> CitronSymbol {
        return .yy0(token)
    }

    func yyInvokeCodeBlockForRule(ruleNumber: CitronRuleNumber) throws -> CitronSymbol {
        switch (ruleNumber) {
        case 0: /* filter ::= set_filter(f) */
            func codeBlockForRule00(f: SearchFilter) throws -> SearchFilter {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 6)
 return f 
#sourceLocation()
}
            if case .yy9(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy9(try codeBlockForRule00(f: f))
            }
        case 1: /* filter ::= manavalue_filter(f) */
            func codeBlockForRule01(f: SearchFilter) throws -> SearchFilter {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 7)
 return f 
#sourceLocation()
}
            if case .yy9(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy9(try codeBlockForRule01(f: f))
            }
        case 2: /* filter ::= name_filter(f) */
            func codeBlockForRule02(f: SearchFilter) throws -> SearchFilter {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 8)
 return f 
#sourceLocation()
}
            if case .yy9(let f) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy9(try codeBlockForRule02(f: f))
            }
        case 3: /* set_filter ::= Set string_comparison(c) text(s) */
            func codeBlockForRule03(c: StringComparison, s: String) throws -> SearchFilter {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 11)

    return .set(c, s)

#sourceLocation()
}
            if case .yy21(let c) = yySymbolOnStack(distanceFromTop: 1),
               case .yy6(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy9(try codeBlockForRule03(c: c, s: s))
            }
        case 4: /* manavalue_filter ::= ManaValue comparison(c) text(s) */
            func codeBlockForRule04(c: Comparison, s: String) throws -> SearchFilter {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 16)

    return .manaValue(c, s)

#sourceLocation()
}
            if case .yy7(let c) = yySymbolOnStack(distanceFromTop: 1),
               case .yy6(let s) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy9(try codeBlockForRule04(c: c, s: s))
            }
        case 5: /* name_filter ::= text(n) */
            func codeBlockForRule05(n: String) throws -> SearchFilter {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 21)

    // TODO: Split on whitespace I guess?
    return .name([n])

#sourceLocation()
}
            if case .yy6(let n) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy9(try codeBlockForRule05(n: n))
            }
        case 6: /* string_comparison ::= Equal */
            func codeBlockForRule06() throws -> StringComparison {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 27)

    return .equal

#sourceLocation()
}
            return .yy21(try codeBlockForRule06())
        case 7: /* string_comparison ::= NotEqual */
            func codeBlockForRule07() throws -> StringComparison {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 30)

    return .notEqual

#sourceLocation()
}
            return .yy21(try codeBlockForRule07())
        case 8: /* comparison ::= Equal */
            func codeBlockForRule08() throws -> Comparison {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 35)

    .equal

#sourceLocation()
}
            return .yy7(try codeBlockForRule08())
        case 9: /* comparison ::= NotEqual */
            func codeBlockForRule09() throws -> Comparison {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 38)

    .notEqual

#sourceLocation()
}
            return .yy7(try codeBlockForRule09())
        case 10: /* comparison ::= LessThan */
            func codeBlockForRule10() throws -> Comparison {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 41)

    .lessThan

#sourceLocation()
}
            return .yy7(try codeBlockForRule10())
        case 11: /* comparison ::= LessThanOrEqual */
            func codeBlockForRule11() throws -> Comparison {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 44)

    .lessThanOrEqual

#sourceLocation()
}
            return .yy7(try codeBlockForRule11())
        case 12: /* comparison ::= GreaterThan */
            func codeBlockForRule12() throws -> Comparison {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 47)

    .greaterThan

#sourceLocation()
}
            return .yy7(try codeBlockForRule12())
        case 13: /* comparison ::= GreaterThanOrEqual */
            func codeBlockForRule13() throws -> Comparison {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 50)

    .greaterThanOrEqual

#sourceLocation()
}
            return .yy7(try codeBlockForRule13())
        case 14: /* text ::= Text(x) */
            func codeBlockForRule14(x: Token) throws -> String {
#sourceLocation(file: "MagicCardSearch/Parser/MagicCardSearchGrammar.y", line: 55)

    if case .text(let text) = x {
        return text
    } else {
        preconditionFailure("lexer did not return Token.text for the Text token")
    }

#sourceLocation()
}
            if case .yy0(let x) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy6(try codeBlockForRule14(x: x))
            }
        default:
            fatalError("Can't invoke code block for rule number \(ruleNumber) - no such rule")
        }
        fatalError("Can't resolve types correctly for invoking code block for rule number \(ruleNumber)")
    }

    private func yySymbolOnStack(distanceFromTop: Int) -> CitronSymbol {
        assert(yyStack.count > distanceFromTop)
        return yyStack[yyStack.count - 1 - distanceFromTop].symbol
    }

    func yyUnwrapResultFromSymbol(_ symbol: CitronSymbol) -> CitronResult {
        if case .yy9(let result) = symbol {
            return result
        } else {
            fatalError("Unexpected mismatch in result type")
        }
    }

    // Error capturing

    typealias CitronErrorCaptureDelegate = _MagicCardSearchGrammarCitronErrorCaptureDelegate

    weak var errorCaptureDelegate: CitronErrorCaptureDelegate? = nil

    let yyErrorCaptureSymbolNumbersForState: [CitronStateNumber:[CitronSymbolNumber]] = [:]
    let yyCanErrorCapture: Bool = false
    let yyErrorCaptureDirectives: [CitronSymbolNumber:(endAfter:[[CitronTokenCode]],endBefore:[CitronTokenCode])] = [:]
    let yyErrorCaptureEndBeforeTokens: Set<CitronSymbolNumber> = []

    let yyErrorCaptureEndAfterSequenceEndingTokens: Set<CitronSymbolNumber> = []

    func yyShouldSaveErrorForCapturing(error: Error) -> Bool {
        fatalError("This parser was not generated with error capturing information")
    }

    func yyCaptureError(on symbolCode: CitronNonTerminalCode, error: Error, state: CitronErrorCaptureState) -> CitronSymbol? {
        fatalError("This parser was not generated with error capturing information")
    }

    func yySymbolContent(_ symbol: CitronSymbol) -> Any { return symbol.typeErasedContent() }

    let yyStartSymbolNumber: CitronSymbolNumber = 10
    let yyEndStateNumber: CitronStateNumber = 5

    var yyErrorCaptureSavedError: (error: Error, isLexerError: Bool)? = nil
    var yyErrorCaptureTokensSinceError: [(token: CitronToken, tokenCode: CitronTokenCode)] = []
    var yyErrorCaptureStackIndices: [Int] = []
    var yyErrorCaptureStartSymbolStackIndex: Int? = nil

    var numberOfCapturedErrors: Int = 0
}

protocol _MagicCardSearchGrammarCitronErrorCaptureDelegate : AnyObject {
    func shouldSaveErrorForCapturing(error: Error) -> Bool
}

extension _MagicCardSearchGrammarCitronErrorCaptureDelegate {
    func shouldSaveErrorForCapturing(error: Error) -> Bool {
        return true
    }
}

// Ability to use == to compare CitronSymbolCode with CitronTokenCode / CitronNonTerminalCode

extension MagicCardSearchGrammar.CitronSymbolCode {
    static func == (a: MagicCardSearchGrammar.CitronSymbolCode, b: MagicCardSearchGrammar.CitronTokenCode) -> Bool {
        guard case let .token(code) = a else { return false }
        return (code == b)
    }
    static func == (a: MagicCardSearchGrammar.CitronTokenCode, b: MagicCardSearchGrammar.CitronSymbolCode) -> Bool {
        guard case let .token(code) = b else { return false }
        return (code == a)
    }
    static func == (a: MagicCardSearchGrammar.CitronSymbolCode, b: MagicCardSearchGrammar.CitronNonTerminalCode) -> Bool {
        guard case let .nonterminal(code) = a else { return false }
        return (code == b)
    }
    static func == (a: MagicCardSearchGrammar.CitronNonTerminalCode, b: MagicCardSearchGrammar.CitronSymbolCode) -> Bool {
        guard case let .nonterminal(code) = b else { return false }
        return (code == a)
    }
}

// Ability to use switch (symbolCode) { case .tokenCode: ...; case .nonterminalCode: ... }

extension MagicCardSearchGrammar.CitronSymbolCode {
    static func ~= (pattern: MagicCardSearchGrammar.CitronTokenCode, value: MagicCardSearchGrammar.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
    static func ~= (pattern: MagicCardSearchGrammar.CitronNonTerminalCode, value: MagicCardSearchGrammar.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
}
