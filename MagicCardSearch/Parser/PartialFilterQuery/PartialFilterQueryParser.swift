// This file is automatically generated by Citron version 2.0.
//
// The parser class defined below conforms to the CitronParser protocol
// defined in CitronParser.swift. 
// 
// The authors of Citron disclaim copyright to the source code in this file.

// Parser class

class PartialFilterQueryParser: CitronParser {

    // Types

    typealias CitronSymbolNumber = UInt8
    typealias CitronStateNumber = UInt8
    typealias CitronRuleNumber = UInt8

    enum CitronTokenCode: CitronSymbolNumber {
      case Or                             =   1
      case And                            =   2
      case Verbatim                       =   3
      case CloseParen                     =   4
      case OpenParen                      =   5
    }

    enum CitronNonTerminalCode: CitronSymbolNumber {
      case query                          =   6
      case disjunction                    =   7
      case conjunction                    =   8
      case parenthesized                  =   9
    }

    enum CitronSymbolCode : RawRepresentable, Equatable {
        case token(CitronTokenCode)
        case nonterminal(CitronNonTerminalCode)
        case endOfInput

        init(_ token: CitronTokenCode) { self = .token(token) }
        init(_ nonterminal: CitronNonTerminalCode) { self = .nonterminal(nonterminal) }
        init(rawValue: CitronSymbolNumber) {
            if (rawValue == 0) {
                self = .endOfInput
            } else if (rawValue < 6) {
                self = .token(CitronTokenCode(rawValue: rawValue)!)
            } else if (rawValue < 10) {
                self = .nonterminal(CitronNonTerminalCode(rawValue: rawValue)!)
            } else {
                fatalError()
            }
        }

        typealias RawValue = CitronSymbolNumber
        var rawValue: CitronSymbolNumber {
            switch (self) {
            case .token(let t): return t.rawValue
            case .nonterminal(let nt): return nt.rawValue
            case .endOfInput: return 0
            }
        }
    }

    typealias CitronToken = PartialFilterQueryTokenContent

    enum CitronSymbol {
        case yyBaseOfStack
        case yy0(CitronToken)
        case yy14(PartialFilterQuery)

        func typeErasedContent() -> Any {
            switch (self) {
            case .yyBaseOfStack: fatalError()
            case .yy0(let value): return value as Any
            case .yy14(let value): return value as Any
            }
        }
    }

    typealias CitronResult = PartialFilterQuery

    // Counts

    let yyNumberOfSymbols: Int = 10
    let yyNumberOfStates: Int = 8

    // Action tables

    let yyLookaheadAction: [(CitronSymbolNumber, CitronParsingAction)] = [
/*   0 */  ( 6, .ACCEPT),   ( 7, .SH( 5)), ( 8, .SH( 6)), ( 9, .RD( 4)), ( 7, .SH( 4)),
/*   5 */  ( 8, .SH( 6)), ( 9, .RD( 4)), ( 3, .SR( 3)), ( 9, .RD( 6)), ( 5, .SH( 1)),
/*  10 */  ( 8, .SH( 7)), ( 9, .RD( 4)), (10, .RD( 2)), ( 3, .SR( 5)), ( 2, .SH( 3)),
/*  15 */  ( 5, .SH( 1)), (10, .RD( 2)), ( 1, .SH( 2)), ( 0, .RD( 0)), ( 1, .SH( 2)),
/*  20 */  ( 4, .SR( 7)),
    ]

    let yyShiftUseDefault: Int = 21
    let yyShiftOffsetMin: Int = 0
    let yyShiftOffsetMax: Int = 18
    let yyShiftOffset: [Int] = [
        /*     0 */     4,    4,    4,   10,   16,   18,   12,   12,
    ]

    let yyReduceUseDefault: Int = -7
    let yyReduceOffsetMin: Int =   -6
    let yyReduceOffsetMax: Int =   2
    let yyReduceOffset: [Int] = [
        /*     0 */    -6,   -3,    2,   -1,
    ]

    let yyDefaultAction: [CitronParsingAction] = [
  /*     0 */  .ERROR , .ERROR , .ERROR , .ERROR , .ERROR ,
  /*     5 */  .ERROR , .RD( 1), .RD( 2),
    ]

    // Fallback

    let yyHasFallback: Bool = false
    let yyFallback: [CitronSymbolNumber] = []

    // Wildcard

    let yyWildcard: CitronSymbolNumber? = nil

    // Rules

    let yyRuleInfo: [(lhs: CitronSymbolNumber, nrhs: UInt)] = [
        (lhs: 6, nrhs: 1),
        (lhs: 7, nrhs: 1),
        (lhs: 7, nrhs: 3),
        (lhs: 8, nrhs: 1),
        (lhs: 8, nrhs: 1),
        (lhs: 8, nrhs: 3),
        (lhs: 8, nrhs: 3),
        (lhs: 9, nrhs: 3),
    ]

    // Stack

    var yyStack: [(stateOrRule: CitronStateOrRule , symbolCode: CitronSymbolNumber, symbol: CitronSymbol)]  = [
        (stateOrRule: .state(0), symbolCode: 0, symbol: .yyBaseOfStack)
    ]
    var maxStackSize: Int? = nil
    var maxAttainedStackSize: Int = 0

    // Tracing

    var isTracingEnabled: Bool = false
    var isTracingPrintsSymbolValues: Bool = false
    var isTracingPrintsTokenValues: Bool = false
    let yySymbolName: [String] = [
    /*  0 */ "$",
    /*  1 */ "Or",
    /*  2 */ "And",
    /*  3 */ "Verbatim",
    /*  4 */ "CloseParen",
    /*  5 */ "OpenParen",
    /*  6 */ "query",
    /*  7 */ "disjunction",
    /*  8 */ "conjunction",
    /*  9 */ "parenthesized",
    ]
    let yyRuleText: [String] = [
        /*   0 */ "query ::= disjunction(d)",
        /*   1 */ "disjunction ::= conjunction(c)",
        /*   2 */ "disjunction ::= disjunction(d) Or conjunction(c)",
        /*   3 */ "conjunction ::= Verbatim(v)",
        /*   4 */ "conjunction ::= parenthesized(d)",
        /*   5 */ "conjunction ::= conjunction(c) And Verbatim(v)",
        /*   6 */ "conjunction ::= conjunction(c) And parenthesized(d)",
        /*   7 */ "parenthesized ::= OpenParen(l) disjunction(d) CloseParen(r)",
    ]

    // Function definitions

    func yyTokenToSymbol(_ token: CitronToken) -> CitronSymbol {
        return .yy0(token)
    }

    func yyInvokeCodeBlockForRule(ruleNumber: CitronRuleNumber) throws -> CitronSymbol {
        switch (ruleNumber) {
        case 0: /* query ::= disjunction(d) */
            func codeBlockForRule0(d: PartialFilterQuery) throws -> PartialFilterQuery {
#sourceLocation(file: "MagicCardSearch/Parser/PartialFilterQuery/PartialFilterQueryGrammar.y", line: 7)
 d 
#sourceLocation()
}
            if case .yy14(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy14(try codeBlockForRule0(d: d))
            }
        case 1: /* disjunction ::= conjunction(c) */
            func codeBlockForRule1(c: PartialFilterQuery) throws -> PartialFilterQuery {
#sourceLocation(file: "MagicCardSearch/Parser/PartialFilterQuery/PartialFilterQueryGrammar.y", line: 11)
 c 
#sourceLocation()
}
            if case .yy14(let c) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy14(try codeBlockForRule1(c: c))
            }
        case 2: /* disjunction ::= disjunction(d) Or conjunction(c) */
            func codeBlockForRule2(d: PartialFilterQuery, c: PartialFilterQuery) throws -> PartialFilterQuery {
#sourceLocation(file: "MagicCardSearch/Parser/PartialFilterQuery/PartialFilterQueryGrammar.y", line: 12)

    .or(.positive, [d, c])

#sourceLocation()
}
            if case .yy14(let d) = yySymbolOnStack(distanceFromTop: 2),
               case .yy14(let c) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy14(try codeBlockForRule2(d: d, c: c))
            }
        case 3: /* conjunction ::= Verbatim(v) */
            func codeBlockForRule3(v: PartialFilterQueryTokenContent) throws -> PartialFilterQuery {
#sourceLocation(file: "MagicCardSearch/Parser/PartialFilterQuery/PartialFilterQueryGrammar.y", line: 18)

    if v.content.first == "-" {
        .term(.init(.negative, String(v.content[1...])))
    } else {
        .term(.init(.positive, v.content))
    }

#sourceLocation()
}
            if case .yy0(let v) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy14(try codeBlockForRule3(v: v))
            }
        case 4: /* conjunction ::= parenthesized(d) */
            func codeBlockForRule4(d: PartialFilterQuery) throws -> PartialFilterQuery {
#sourceLocation(file: "MagicCardSearch/Parser/PartialFilterQuery/PartialFilterQueryGrammar.y", line: 25)
 d 
#sourceLocation()
}
            if case .yy14(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy14(try codeBlockForRule4(d: d))
            }
        case 5: /* conjunction ::= conjunction(c) And Verbatim(v) */
            func codeBlockForRule5(c: PartialFilterQuery, v: PartialFilterQueryTokenContent) throws -> PartialFilterQuery {
#sourceLocation(file: "MagicCardSearch/Parser/PartialFilterQuery/PartialFilterQueryGrammar.y", line: 26)

    let term = if v.content.first == "-" {
        FilterQuery.term(.init(.negative, String(v.content[1...])))
    } else {
        FilterQuery.term(.init(.positive, v.content))
    }
    .and(.positive, [c, term])

#sourceLocation()
}
            if case .yy14(let c) = yySymbolOnStack(distanceFromTop: 2),
               case .yy0(let v) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy14(try codeBlockForRule5(c: c, v: v))
            }
        case 6: /* conjunction ::= conjunction(c) And parenthesized(d) */
            func codeBlockForRule6(c: PartialFilterQuery, d: PartialFilterQuery) throws -> PartialFilterQuery {
#sourceLocation(file: "MagicCardSearch/Parser/PartialFilterQuery/PartialFilterQueryGrammar.y", line: 34)

    .and(.positive, [c, d])

#sourceLocation()
}
            if case .yy14(let c) = yySymbolOnStack(distanceFromTop: 2),
               case .yy14(let d) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy14(try codeBlockForRule6(c: c, d: d))
            }
        case 7: /* parenthesized ::= OpenParen(l) disjunction(d) CloseParen(r) */
            func codeBlockForRule7(l: PartialFilterQueryTokenContent, d: PartialFilterQuery, r: PartialFilterQueryTokenContent) throws -> PartialFilterQuery {
#sourceLocation(file: "MagicCardSearch/Parser/PartialFilterQuery/PartialFilterQueryGrammar.y", line: 40)

    .or(l.content.first == "-", [d])

#sourceLocation()
}
            if case .yy0(let l) = yySymbolOnStack(distanceFromTop: 2),
               case .yy14(let d) = yySymbolOnStack(distanceFromTop: 1),
               case .yy0(let r) = yySymbolOnStack(distanceFromTop: 0) {
                return .yy14(try codeBlockForRule7(l: l, d: d, r: r))
            }
        default:
            fatalError("Can't invoke code block for rule number \(ruleNumber) - no such rule")
        }
        fatalError("Can't resolve types correctly for invoking code block for rule number \(ruleNumber)")
    }

    private func yySymbolOnStack(distanceFromTop: Int) -> CitronSymbol {
        assert(yyStack.count > distanceFromTop)
        return yyStack[yyStack.count - 1 - distanceFromTop].symbol
    }

    func yyUnwrapResultFromSymbol(_ symbol: CitronSymbol) -> CitronResult {
        if case .yy14(let result) = symbol {
            return result
        } else {
            fatalError("Unexpected mismatch in result type")
        }
    }

    // Error capturing

    typealias CitronErrorCaptureDelegate = _PartialFilterQueryParserCitronErrorCaptureDelegate

    weak var errorCaptureDelegate: CitronErrorCaptureDelegate? = nil

    let yyErrorCaptureSymbolNumbersForState: [CitronStateNumber:[CitronSymbolNumber]] = [
          0 : [6, 7, 8, 9],
          1 : [7, 8, 9],
          2 : [8, 9],
          3 : [9],
    ]
    let yyCanErrorCapture: Bool = true
    let yyErrorCaptureDirectives: [CitronSymbolNumber:(endAfter:[[CitronTokenCode]],endBefore:[CitronTokenCode])] = [
         7 : (endAfter: [[.Or]],
              endBefore: []),
         8 : (endAfter: [[.And]],
              endBefore: []),
         9 : (endAfter: [],
              endBefore: [.CloseParen, .Verbatim, .Or, .And])
    ]
    let yyErrorCaptureEndBeforeTokens: Set<CitronSymbolNumber> = [
        1, 2, 3, 4
    ]
    let yyErrorCaptureEndAfterSequenceEndingTokens: Set<CitronSymbolNumber> = [
        1, 2
    ]

    func yyShouldSaveErrorForCapturing(error: Error) -> Bool {
        guard let delegate = errorCaptureDelegate else {
            print("Error capture: Not saving error for capturing because errorCaptureDelegate is not set")
            return false
        }
        return delegate.shouldSaveErrorForCapturing(error: error)
    }

    func yyCaptureError(on symbolCode: CitronNonTerminalCode, error: Error, state: CitronErrorCaptureState) -> CitronSymbol? {
        guard let delegate = errorCaptureDelegate else {
            print("Error capture: Not capturing error because errorCaptureDelegate is not set")
            return nil
        }

        switch (symbolCode) {
        case .query:
            let delegateResponse = delegate.shouldCaptureErrorOnQuery(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy14(symbol)
            case .dontCapture:
                return nil
            }
        case .disjunction:
            let delegateResponse = delegate.shouldCaptureErrorOnDisjunction(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy14(symbol)
            case .dontCapture:
                return nil
            }
        case .conjunction:
            let delegateResponse = delegate.shouldCaptureErrorOnConjunction(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy14(symbol)
            case .dontCapture:
                return nil
            }
        case .parenthesized:
            let delegateResponse = delegate.shouldCaptureErrorOnParenthesized(state: state, error: error)
            switch (delegateResponse) {
            case .captureAs(let symbol):
                return .yy14(symbol)
            case .dontCapture:
                return nil
            }
        }
    }

    func yySymbolContent(_ symbol: CitronSymbol) -> Any { return symbol.typeErasedContent() }

    let yyStartSymbolNumber: CitronSymbolNumber = 6
    let yyEndStateNumber: CitronStateNumber = 5

    var yyErrorCaptureSavedError: (error: Error, isLexerError: Bool)? = nil
    var yyErrorCaptureTokensSinceError: [(token: CitronToken, tokenCode: CitronTokenCode)] = []
    var yyErrorCaptureStackIndices: [Int] = []
    var yyErrorCaptureStartSymbolStackIndex: Int? = nil

    var numberOfCapturedErrors: Int = 0
}

protocol _PartialFilterQueryParserCitronErrorCaptureDelegate : AnyObject {
    func shouldSaveErrorForCapturing(error: Error) -> Bool

    /* query */
    func shouldCaptureErrorOnQuery(state: PartialFilterQueryParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<PartialFilterQuery>

    /* disjunction */
    func shouldCaptureErrorOnDisjunction(state: PartialFilterQueryParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<PartialFilterQuery>

    /* conjunction */
    func shouldCaptureErrorOnConjunction(state: PartialFilterQueryParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<PartialFilterQuery>

    /* parenthesized */
    func shouldCaptureErrorOnParenthesized(state: PartialFilterQueryParser.CitronErrorCaptureState,
        error: Error) -> CitronErrorCaptureResponse<PartialFilterQuery>
}

extension _PartialFilterQueryParserCitronErrorCaptureDelegate {
    func shouldSaveErrorForCapturing(error: Error) -> Bool {
        return true
    }
}

// Ability to use == to compare CitronSymbolCode with CitronTokenCode / CitronNonTerminalCode

extension PartialFilterQueryParser.CitronSymbolCode {
    static func == (a: PartialFilterQueryParser.CitronSymbolCode, b: PartialFilterQueryParser.CitronTokenCode) -> Bool {
        guard case let .token(code) = a else { return false }
        return (code == b)
    }
    static func == (a: PartialFilterQueryParser.CitronTokenCode, b: PartialFilterQueryParser.CitronSymbolCode) -> Bool {
        guard case let .token(code) = b else { return false }
        return (code == a)
    }
    static func == (a: PartialFilterQueryParser.CitronSymbolCode, b: PartialFilterQueryParser.CitronNonTerminalCode) -> Bool {
        guard case let .nonterminal(code) = a else { return false }
        return (code == b)
    }
    static func == (a: PartialFilterQueryParser.CitronNonTerminalCode, b: PartialFilterQueryParser.CitronSymbolCode) -> Bool {
        guard case let .nonterminal(code) = b else { return false }
        return (code == a)
    }
}

// Ability to use switch (symbolCode) { case .tokenCode: ...; case .nonterminalCode: ... }

extension PartialFilterQueryParser.CitronSymbolCode {
    static func ~= (pattern: PartialFilterQueryParser.CitronTokenCode, value: PartialFilterQueryParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
    static func ~= (pattern: PartialFilterQueryParser.CitronNonTerminalCode, value: PartialFilterQueryParser.CitronSymbolCode) -> Bool {
        return (pattern == value)
    }
}
